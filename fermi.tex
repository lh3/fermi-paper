\documentclass{bioinfo}
\copyrightyear{2012}
\pubyear{2012}

\usepackage[ruled,vlined]{algorithm2e}

\usepackage{natbib}
\bibliographystyle{apalike}

\DeclareMathOperator*{\argmax}{argmax}

\begin{document}
\firstpage{1}

\title[Variant calling from de novo assembly]{Exploring single-sample SNP and INDEL calling with
whole-genome de novo assembly}

\author[Li]{Heng Li$^{1,}$\footnote{to whom correspondence should be addressed}}

\address{$^1$Broad Institute, 7 Cambridge Center, Cambridge, MA 02142, USA}

\history{Received on XXXXX; revised on XXXXX; accepted on XXXXX}
\editor{Associate Editor: XXXXXXX}
\maketitle

\begin{abstract}

\section{Motivation:}
Eugene Myers in his string graph paper~\citep{Myers:2005bh} suggested that in a
string graph or equivalently a unitig graph, any path spells a valid assembly.
As a string/unitig graph also encodes every valid assembly of reads, such a
graph, provided that it can be constructed correctly, is in fact a lossless
representation of reads. In principle, every analysis based on whole-genome
shotgun sequencing (WGS) data, such as SNP and insertion/deletion (INDEL)
calling, can also be achieved with unitigs.

\section{Results:}
To explore the feasibility of using de novo assembly in the context of
resequencing, we developed a de novo assembler, \emph{fermi}, that assembles
Illumina short reads into unitigs while preserving most of information of the
input reads. SNPs and INDELs can be called by mapping the unitigs against a
reference genome. By applying the method on 35-fold human resequencing data,
we showed that in comparison to the standard pipeline, our approach yields
similar accuracy for SNP calling and better results for INDEL calling. It has
higher sensitivity than other de novo assembly based methods for variant
calling. Our work suggests that variant calling with de novo assembly be a
beneficial complement to the standard variant calling pipeline for whole-genome
resequencing.

\section{Availability:} http://github.com/lh3/fermi
\section{Contact:} hengli@broadinstitute.org
\end{abstract}

\section{INTRODUCTION}

The rapidly decreasing sequencing cost has enabled whole-genome shotgun (WGS)
resequencing at an affordable price. Many software packages have been developed
to call variants, including SNPs, short insertions and deletions (INDELs) and
structural variations (SVs), from WGS data. At present, the standard approach to
variant calling is to map raw sequence reads against a reference genome and then
to detect differences from the reference. It is well established and has been
proved to work from a single sample to thousands of
samples~\citep{1000-Genomes-Project-Consortium:2010qc}. Nonetheless, a
fundamental flaw in this mapping based approach is that mapping algorithms
ignore the correlation between sequence reads. They are unable to take full
advantage of data and may produce inconsistent outputs which complicate variant
calling.  This flaw has gradually attracted the attention of various research
groups who subsequently proposed several methods to alleviate the effect,
including post alignment
filtering~\citep{Li:2008zr,Ossowski:2008if,Krawitz:2010zr}, iterative
mapping~\citep{Manske:2009ve}, read
realignment~\citep{Albers:2010ud,Homer:2010kx,Li:2011kx,Depristo:2011vn} and
local assembly~\citep{Carnevali:2011fk}.  However, because these methods still
rely on the initial mapping, it is difficult for them to identify and recover
mismapped or unmapped reads due to high sequence divergence, long INDELs, SVs,
copy number changes or misassemblies. They have not solved the problem from the
root.

Another approach to variant calling that fundamentally avoids the flaw of the
mapping based approach is to assemble sequence reads into contigs and to
discover variants via assembly-to-assemby alignment. It was probably more
widely used in the era of capillary sequencing. The assembly based method
became less used since 2008 due to the great difficulties in assembling 25bp
reads, but with longer paired-end reads and improved methodology,
de novo assembly is reborn as the preferred choice for variant discovery
between small genomes.

For variant discovery between human genomes, however, the assembly based
approach has not attracted much attention. Assembling a human genome is far
more difficult than assembling a bacterial genome, firstly due to the sheer
size of the genome, secondly to the rich repeats and thirdly due to the
diploidy of the human genome. Many heuristics effective for assembling small
genomes are not directly applicable to the human genome assembly. As a result,
only a few de novo assemblers have been applied on human short-read data. Among
them, ABySS~\citep{Simpson:2009ys}, SOAPdenovo~\citep{Li:2010vn} and
SGA~\citep{Simpson:2011ly}, as of now, do not explicitly output heterozygotes.
Although in theory it is possible to recover heterozygotes from their
intermediate output, it may be difficult in practice as the assemblers may not
distinguish heterozygotes from sequencing errors. Cortex~\citep{Iqbal:2012ys}
is specifically designed for retaining heterozygous variants in an assembly,
but it may be missing heterozygotes. ALLPATHS-LG~\citep{Gnerre:2011ys}
also paid particular attention to keep heterozygotes, but it still has
relatively a low sensitivity. In addition, ALLPATHS-LG only works with
reads from libraries with distinct insert size distributions and prefers read
pairs with mean insert size below three times of the read length, while many
resequencing projects do not meet these requirements and thus ALLPATHS-LG may
not be applied or work to the best performance. Even if we also include de novo
assemblers developed for capillary sequence reads, the version of the Celera
assembler used for assembling the HuRef genome~\citep{Levy:2007uq} is the only
one that retains heterozygotes while capable of assembling a mammalian genome.
At last, one may think to map sequence reads back to the assembled contigs to
recover heterozygous events, but this
procedure will be affected by the same flaw of read mapping. To the best of our
knowledge, no existing de novo assemblers are able to achieve the sensitivity
of the standard mapping based approach for a diploid mammalian genome.

In this article, we will show the first time that the assembly based variant
calling can achieve a SNP accuracy close to the standard mapping approach
and have particular strength in INDEL calling, confirming previous
studies~\citep{Iqbal:2012ys}. In addition, the de novo assembly
algorithm, \emph{fermi}, developed for this practice is also a capable
assembler for human assembly.

\begin{methods}
\section{METHODS}
\subsection{Theoretical background}
\subsubsection{A history of the overlap-layout-consensus paradigm}
Computer assisted sequence assembly can be dated back to the late
1970s~\citep{Staden:1979dq,Gingeras:1979cr}. 
In 1984, \citeauthor{Peltola:1984qf} first formulated the DNA assembling
problem as finding the shortest string (the assembly) such that each sequence
read can be mapped to the assembly within a required error rate.
To solve the problem, they proposed a three-step procedure, which is
essentially the overlap-layout-consensus (OLC) approach.

\citet{Myers:1995nx} pointed out that reducing DNA assembly to a shortest
string problem is flawed in the presence of repeat. He (see also
\citealt{DBLP:journals/algorithmica/KececiogluM95}) further proposed the
concept of \emph{overlap graph}, where a vertex corresponds to a read and a
bidirectional edge to an overlap. Naively, the DNA assembling problem can be
cast as finding a path in the overlap graph such that each vertex/read is
visited exactly once (though edge/overlap caused by repeats are not required to
be traversed), equivalent to a Hamilton path
problem~\citep{Compeau:2011fk,Li:2011zr} which is known to be NP-complete. This
has led many to believe that the OLC approach is theoretically crippled.

However, this is a misbelief. Although the assembly problem can be reduced to a
Hamilton path problem, it can be reduced to other problems as well and in
practice almost no assemblers try to solve a Hamilton path problem.  We note
that a fundamental difference between a generic graph and an overlap graph is
that the latter can be transitively reduced while retaining the read
relationship. More formally, if $v_1\to v_2$, $v_2\to v_3$ and $v_1\to v_3$ are
all present, edge $v_1\to v_3$ is said to be \emph{reducible}. When we removed
all the contained reads and reducible edges, a procedure called
\emph{transitive reduction}, the resulting graph is still a loyal
representation of the overlap graph~\citep{Myers:1995nx}, but the path
corresponding to the assembly is not a Hamilton path any more because reads
from repetitive regions need to be traversed multiple times.

In a transitively reduced graph, if there exists $v_1\to v_2$ with the
out-degree of $v_1$ and in-degree of $v_2$ both equal to 1, we are able to
merge $v_1$ and $v_2$ into one vertex without altering the topology of the
graph. After we performed all possible merges, we get a \emph{unitig graph} in
which each vertex corresponds to a \emph{unitig}, representing a maximal linear
sequence that can be resolved by reads. Multiple copies of a repeat may be
collapsed to a single unitig. The concept of unitig helps to greatly simplify
an assembly graph. It has played a central role in the Celera
assembler~\citep{Myers:2000kl}.

On the other hand, introducing unitigs has not theoretically solved the
sequence assembly to the end. \citet{Myers:2005bh}, based on the suggestion
by~\citet{Pevzner:2001vn}, proposed to compute a traversal count for each edge
and to remove false overlap edges by solving a minimum cost network flow
problem. Finding the optimal assembly in the resultant graph can be reduced to
a Eulerian path problem, which has a linear time solution. Myers originally
applied this procedure to \emph{string graph}, an equivalence to unitig graph.
\citet{Medvedev:2009ve} pointed out that determining the traversal count can
also be resolved directly in the bidirectional unitig graph using a bidirected
network flow-based algorithm.

Once we get a transitively reduced graph, the following steps can be achieved
in roughly linear time most of time -- the worst case almost never happens
globally in practice. However, deriving an overlap graph takes $O(N^2)$ time,
where $N$ is the number of reads, and transitive reduction takes at least
$O(E)$ time, where $E$ is the number of edges which is usually much larger than
$N$. This still makes an OLC based approach less favorable in short-read
assembly where $N$ can be of the order of $10^9$.

A breakthrough achieved by~\citet{Simpson:2010uq} finally solved
this last remaining problem at least when we only consider exact overlaps.
These authors developed a $O(N)$ algorithm to find all the irreducible edges,
effectively replacing the overlapping and transitive reduction phases.

In summary, in the OLC paradigm, the sequence assembly problem can be
practically solved in a time roughly linear in the total length of reads.

\subsubsection{De Bruijn graph and read coherence}
De Bruijn graph is an alternative graph representation of sequence
reads~\citep{Idury:1995oq}.  It can be trivially constructed with a simple
linear-time algorithm. This makes the de Bruijn graph approach very attractive
for assembling many short reads.

However, de Bruijn is `lossy'. From a theoretical point view, a de Bruijn graph
is equivalent to an overlap graph built by splitting a long read into overlap
$k$-mers and requiring ($k$-1)-mer exact overlaps between non-redundant
$k$-mers.  Such a graph does not have transitive edges. Because long reads all
effectively work as $k$-bp reads in a de Bruijn graph, longer range information
is lost and as a result, a path in the graph may be invalidated by reads. In
contrast, in a unitig graph or equivalently a string graph each path models a
valid assembly from input reads. \citet{Myers:2005bh} called this property of
path consistency as \emph{read coherence}.

Losing the long-range information in reads, a de Bruijn graph by itself has
reduced power to resolve short repeats. This flaw is usually amended by mapping
reads back to the graph and bisecting repeats shorter than the reads, a procedure
some called as \emph{read threading}. Many de Buijn graph based assemblers
essentially take this
strategy~\citep{Pevzner:2001vn,Chaisson:2009fk,Zerbino:2009ly,Li:2010vn},
though they may use different terminologies.

With read threading, it is theoretically possible to transform a de Bruijn graph
to a coherent graph, but in practice, threading is not straightforward and
may be inefficient given complex repeat structures. For a coherent representation
of reads, a unitig graph is simpler to construct.

\subsubsection{Concluding remark}
We noted that we only focused on the theoretical aspects of de novo assembly.
In practice, many assemblers derived the final assembly by applying heuristics
on the simplified graph instead of solving a network flow problem or a Eulerian
problem. Furthermore, correcting errors, utilizing read pairs and controlling memory
usage all pose challenges to large-scale de novo assembly. Many practical
problems are not solved perfectly. De novo assembly is still a field under
active development.

\subsection{Rationale}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{Sequence index $i\ge0$}
\KwOut{Sequence $P$ and $k$, the rank of $P$}
\BlankLine
\textbf{Function} {\sc RetrieveSeq}$(i)$
\Begin {
	$k\gets i$\;
	$P\gets\epsilon$\;
	\While{\bf true} {
		$a\gets B[k]$\;
		$k\gets C(a)+O(a,k)-1$\;
		\If{$a=0$}{
			\Return $(P,k)$
		}
		$P\gets aP$
	}
}
\caption{Sequence retrieval}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{Bi-interval $(k,l,s)$ of string $W$ and a symbol $a$}
\KwOut{Bi-interval of string $aW$}
\BlankLine
\textbf{Function} {\sc BackwardExt}$(a,k,l,s)$
\Begin {
	\For{$b\gets0$ \KwTo $5$} {
		$k_b\gets C(b) + O(b,k-1)$
		$s_b\gets O(b,k+s-1) - O(b,k-1)$
	}
	$l_0\gets l$\;
	$l_4\gets l_0+s_0$\;
	\For{$b\gets3$ \KwTo $1$} {
		$l_b\gets l_{b+1}+s_{b+1}$
	}
	$l_5\gets l_1+s_1$\;
	\Return{$(k_a,l_a,s_a)$}
}
\caption{Backward extension}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{Bi-interval $(k,l,s)$ of string $W$ and a symbol $a$}
\KwOut{Bi-interval of string $Wa$}
\BlankLine
\textbf{Function} {\sc ForwardExt}$(a,k,l,s)$
\Begin {
	$(l',k',s')\gets${\sc BackwardExt}$(\overline{a},l,k,s)$\;
	\Return{$(k',l',s')$}
}
%\textbf{Function} {\sc ForwardExt}$(a,k,l,s)$
%\Begin {
%	\For{$b\gets0$ \KwTo $5$} {
%		$l_a\gets C(b) + O(b,l-1)$
%		$s_a\gets O(b,l+s-1) - O(b,l-1)$
%	}
%	$k_0\gets k$\;
%	$k_4\gets k_0+s_0$\;
%	\For{$b\gets3$ \KwTo $1$} {
%		$k_b\gets k_{b+1}+s_{b+1}$
%	}
%	$k_5\gets k_1+s_1$\;
%	$b\gets\overline{a}$\;
%	\Return{$(k_b,l_b,s_b)$}
%}
\caption{Forward extension}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{Read $P$ and the minimum overlap length $x$}
\KwOut{Array of bi-intervals of reads having irreducible overlaps with the 3'-end of $P$}
\BlankLine
\textbf{Function} {\sc IrrOverlap}$(P,x)$
\Begin {
	\emph{Initialize ${\sf IrrOvlp}$, ${\sf Curr}$ and ${\sf Prev}$ as empty arrays}\;
	$a\gets P[|P|-1]$\;
	\nl$(k,l,s)\gets (C(a), C(\overline{a}), C(a+1) - C(a))$\;
	\nl\For{$i\gets |P|-2$ \KwTo $0$} {
		\If{$|P|-i-1\ge x$} {
			$(k',l',s')\gets${\sc BackwardExt$(0,k,l,s)$}\;
			\If{$s'\not=0$} {
				\emph{Append $(k',l',s';i;\epsilon)$ to ${\sf Curr}$}\;
			}
		}
		$(k,l,s)\gets${\sc BackwardExt$(P[i],k,l,s)$}\;
	}
	\nl\emph{Reverse array ${\sf Curr}$, and swap ${\sf Curr}$ and ${\sf Prev}$}\;
	\nl${\sf Finished}=\emptyset$\;
	\nl\While{${\sf Prev}$ is not empty} {
		\emph{Reset ${\sf Curr}$ to empty}\;
		\For{$(k,l,s;i;W)$ {\bf in} ${\sf Prev}$} {
			\If{$W\in{\sf Finished}$} {
				{\bf continue}\;
			}
			$(k',l',s')\gets${\sc ForwardExt}$(0,k,l,s)$\;
			\If{$s'\not=0$} {
				${\sf Finished}\gets{\sf Finished}\cup \{W\}$\;
				\emph{Append $(k',l',s';i;W)$ to ${\sf IrrOvlp}$}\;
				{\bf continue}\;
			}
			\For{$a\gets1$ \KwTo $5$} {
				$(k',l',s')\gets${\sc ForwardExt}$(a,k,l,s)$\;
				\If{$s'\not=0$} {
					\emph{Append $(k',l',s';Wa)$ to ${\sf Curr}$}\;
				}
			}
		}
		\emph{Swap ${\sf Curr}$ and ${\sf Prev}$}
	}
	\Return{${\sf IrrOvlp}$}
}
\caption{Finding irreducible overlaps (SD10)}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{String $P$ and start position $i_0$; $P[-1]=0$}
\KwOut{Set of bi-intervals of SMEMs overlapping $i_0$}
\BlankLine
\textbf{Function} {\sc SuperMEM1}$(P,x)$
\Begin {
	\emph{Initialize ${\sf Curr}$, ${\sf Prev}$ and ${\sf Match}$ as empty arrays}\;
	\nl$(k,l,s)\gets (C(P[i_0]), C(\overline{P[i_0]}), C(P[i_0]+1) - C(P[i_0]))$\;
	\nl\For{$i\gets i_0+1$ \KwTo $|P|$} {
		\If{$i=|P|$} {
			\emph{Append $(k,l,s)$ to ${\sf Curr}$}
		} \Else {
			$(k',l',s')\gets${\sc ForwardExt$(P[i],k,l,s)$}\;
			\nl\If{$s'\not=s$} {
				\emph{Append $(k,l,s)$ to ${\sf Curr}$}
			}
			\If{$s'=0$} {
				{\bf break}\;
			}
			$(k,l,s)\gets(k',l',s')$
		}
	}
	\emph{Swap array ${\sf Curr}$ and ${\sf Prev}$}\;
	$i'\gets |P|$\;
	\nl\For{$i\gets i_0-1$ \KwTo $-1$} {
		\emph{Reset ${\sf Curr}$ to empty}\;
		$s''\gets -1$\;
		\For{$(k,l,s)$ {\bf in} ${\sf Prev}$}{
			$(k',l',s')\gets${\sc BackwardExt$(P[i],k,l,s)$}\;
			\nl\If{$s' = 0$ {\bf or} $i = -1$} {
				\nl\If{${\sf Curr}$ is empty {\bf and} $i+1<i'+1$} {
					$i'\gets i$\;
					\emph{Append $(k,l,s)$ to ${\sf Match}$}
				}
			}
			\nl\If{$s'\not=0$ {\bf and} $s'\not=s''$} {
				$s''\gets s'$\;
				\emph{Append $(k,l,s)$ to ${\sf Curr}$}
			}
		}
		\If{${\sf Curr}$ is empty} {
			{\bf break}
		}
		\emph{Swap ${\sf Curr}$ and ${\sf Prev}$}\;
	}
	\Return ${\sf Match}$
}
\caption{Finding super-maximal exact matches}
\end{algorithm}

\begin{algorithm}[h]
\DontPrintSemicolon
\footnotesize
\KwIn{FM-index and the minimum overlap length $x$}
\KwOut{Unitig graph $G=(V,E)$}
\BlankLine
\textbf{Function} {\sc Unitig}$(V,E,x,i)$
\Begin {
	\textbf{Function} {\sc SemiExt$(P,k,x)$}
	\Begin {
		\While{\bf true} {
			${\sf IrrOvlp}\gets${\sc IrrOverlap}$(P,x)$\;
			\If{${\sf \#IrrOvlp}=1$} {
				$(k',l',s';i;W)\gets{\sf IrrOvlp}[1]$\;
				${\sf IrrOvlp}'\gets${\sc IrrOverlap}$(\overline{P_i\circ W},x)$\;
				\If{${\sf \#IrrOvlp}'=1$} {
					$P\gets P\circ W$\;
					$k\gets l'$\;
					{\bf continue}\;
				}
			}
			\For{$(k',l',s';i;W)$ {\bf in} ${\sf IrrOvlp}$} {
				$E\gets E\cup \{(k,k')\}$
			}
			\Return{$(P,k)$}
		}
	}
	\BlankLine
	$(P,k)\gets${\sc RetrieveSeq}$(i)$\;
	$(P',k')\gets${\sc RetrieveSeq}$(i+1)$\;
	$(P,k')\gets${\sc SemiExt}$(P,k',x)$\;
	$(P,k)\gets${\sc SemiExt}$(\overline{P},k,x)$\;
	$V\gets V\cup\{(k',k;P)\}$
}
\caption{Backward extension}
\end{algorithm}

\end{methods}

\section{RESULTS}

\subsection{Implementation}
We implemented a new de novo assembler, fermi, with a particular emphasis on
preserving short variants. It is designed to take advantage of multiple
processors of a machine with large shared memory.

\subsection{Evaluated call sets}

\begin{table}[!htb]
\processtable{Evaluated SNP and INDEL call sets}
{\begin{tabular}{lllll}
\toprule
Label & Data & Assembler & Mapper & Caller \\
\midrule
AS & 96X Illumina PE$^1$ & AllPaths-LG & BWA-SW$^2$ & SAMtools$^3$ \\
BS & 60X Illumina PE & & BWA$^4$ & SAMtools \\
CG & Complete Genomics& & cgatools2$^5$ & cgatools2 \\
CV & 26X Illumina SE$^6$ & Cortex & & Cortex-var \\
FS & 30X Illumina SE$^6$ & fermi & BWA-SW$^2$ & SAMtools$^3$ \\
MD & 60X multiple        & & MAQ & 1000g pilot$^7$ \\
SS & 30X Illumina SE$^6$ & & BWA-SW & SAMtools \\
TS & 30X Illumina SE$^6$ & & Bowtie2 & SAMtools \\
\botrule
\end{tabular}}{
$^1$ AS uses reads from Illumina jumping and fosmid libraries\\
$^2$ BWA-SW is invoked with `bwa bwasw -b9 -q16 -r1 -w500'\\
$^3$ INDELs are called from pileup without going through the SAMtools caller\\
$^4$ Realigned by GATK~\citep{Depristo:2011vn} also around known INDELs\\
$^5$ Only `VQHIGH' calls are retained\\
$^6$ CV, FS, SS and TS do not use the pairing information in calling\\
$^7$ 1000 Genomes Project pilot calls; generated from Dindel and multiple SNP callers\\
}
\end{table}

\subsection{Performance on SNP calling}

\begin{table}[!htb]
\processtable{Statistics of SNP call sets}
{\begin{tabular}{p{1.5cm}rrrrrrr}
\toprule
& FS & CV & SS & TS & BS & CG & MD \\
\midrule
\#SNPs (M) & 3.37 & 2.20 & 3.24 & 3.34 & 3.50 & 3.34 & 2.69\\
\#hets (M) & 1.96 & 1.04 & 1.94 & 1.99 & 2.11 & 2.04 & 1.65\\
ts/tv      & 2.04 & 2.03 & 2.08 & 2.09 & 2.11 & 2.12 & 2.06\\
DN50 (bp)  & 3,602& 6,662& 3,523& 3,428& 3,392& 3,447&3,992\\
DN2/DN50   & 22.1 & 20.8 & 23.4 & 21.8 & 22.7 & 22.3 & 22.9\\
\botrule
\end{tabular}}{}
\end{table}

\subsection{Performance on INDEL calling}

%         FS     CV     SS     BS     CG     MD     AS   sum1   sum2   sum3
% ------------------------------------------------------------------
% FS  383078 198513 295926 332481 237810 223302 235105 352900        364167
% CV  219795 251769 207981 222029 182752 178131 164424 229231 231985 232448
% SS  292270 190528 322095 309800 222997 222804 199882 313746 318967 319350
% BS  330405 201341 312624 404646 241722 228431 229152 336172 363859 372496
% CG  237294 166611 224035 242198 264696 199071 161052 247969 253760 255437
% MD  219497 163070 220968 225339 196936 240424 149753 231786 234230 235027
% AS  231508 143791 200100 227719 160311 151455 323423 242816 253042 253358

\begin{table*}[!htb]
\processtable{Fraction of INDELs found in other call sets\label{tab:indel}}
{\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lrrrrrrrrr}
\toprule
&FS&CV&SS&BS&CG&MD&SS+BS+CG+MD&SS+BS+CG+MD+FS&SS+BS+CG+MD+FS+CV+AS\\
\midrule
FS&383,078& 0.518 & 0.772 & 0.868 & 0.620 & 0.583 & 0.921 &       & 0.951\\
CV& 0.873 &251,769& 0.826 & 0.882 & 0.726 & 0.708 & 0.910 & 0.921 & 0.923\\
SS& 0.908 & 0.592 &322,095& 0.962 & 0.692 & 0.692 & 0.974 & 0.990 & 0.991\\
BS& 0.816 & 0.498 & 0.772 &404,646& 0.597 & 0.564 & 0.831 & 0.899 & 0.920\\
CG& 0.896 & 0.629 & 0.846 & 0.915 &264,696& 0.752 & 0.937 & 0.958 & 0.965\\
MD& 0.913 & 0.678 & 0.919 & 0.937 & 0.819 &240,424& 0.964 & 0.974 & 0.978\\
\botrule
\end{tabular*}}
{INDELs that start within a homopolymer run longer than 6bp are excluded in
all call sets. An INDEL in call set $R$ (indexed by row) is said to
found in call set $C$ (indexed by column) if there exists an INDEL in $C$
such that the left-aligned starting positions of the two INDELs are within 20bp
from each other.  An INDEL in $R$ is considered to be found in
`\mbox{SS+BS+CG+MD}' if it is found in one of SS, BS, CG and MD, but excluding $R$
itself. The similar is true for the `\mbox{SS+BS+CG+MD+FS}' and the
`\mbox{SS+BS+CG+MD+FS+CV+AS}' columns. In the table, a number on the diagonal equals $|R|$,
the number of INDEL calls in the call set. The fraction equals $|\{g\in R:g
\mbox{ is found in } C\}|/|R|$.}

\end{table*}

\subsection{Performance on de novo assembly}

\begin{table}[!htb]
\processtable{Statistics on human whole-genome assemblies}
{\begin{tabular}{lrrrrr}
\toprule
& AllPaths & fermi & SGA & SOAP & HuRef \\
\midrule
Raw contig bases & 2.61G & 2.92G & 2.76G & 2.88G & 2.81G \\
Aligned contig bases & 2.61G & 2.88G & 2.75G & 2.87G & 2.81G \\
Aligned N50 & 23.8k & 11.3k & 9.9k & 6.6k & 103.4k \\
Covered ref. bases & 2.59G & 2.75G & 2.70G & 2.73G & 2.78G \\
\# break points & 6,511 & 3,173 & 2,997 & 1,960 & 9,174 \\
\# $[300,350]$ bp del. & 2,370 & 678 & 777 & 427 & 1,075 \\
\# $[300,350]$ bp ins. & 170 & 60 & 57 & 81 & 752 \\
\botrule
\end{tabular}}{}
\end{table}

\section*{ACKNOWLEDGEMENTS}

\paragraph{Funding\textcolon} NIH 1U01HG005208-01.
\bibliography{fermi}

\end{document}
